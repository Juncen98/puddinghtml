<html>
<head>
<link rel="stylesheet" href="josh.css">
</head>
<body bgcolor="#FFFFFF" text="#000000">
<DIV ID="DESCRIPTION">
  <table width="100%" cellspacing="0" cellpadding="0" border="0">
    <tr>
      <td valign="top" class="name">Scalar Functions</td>
      <td valign="top" nowrap class="compatibility"> </td>
    </tr>
    <tr>
      <td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"> <p>Scalar functions fall
          into the categories listed in Table 4.2.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"><span class="title">Categories
          of Scalar Functions </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <table border="1" width="60%">
          <tr>
            <th> <p>Function Category</p></th>
            <th> <p>Explanation</p></th>
          </tr>
          <tr>
            <td> <p>Built-in</p></td>
            <td> <p>Performs operations on values or settings built into the
                database.</p>
              <p>Oracle uses the term "built-in" to describe all the specialty
                functions that are provided by Oracle, and thus "built into" their
                DBMS. This is a distinct and septe usage from the built-in functions
                described here.</p></td>
          </tr>
          <tr>
            <td> <p>Date &amp; Time</p></td>
            <td> <p>Performs operations on datetime fields and returns values
                in datetime format.</p></td>
          </tr>
          <tr>
            <td> <p>Numeric</p></td>
            <td> <p>Performs operations on numeric values and returns numeric
                values.</p></td>
          </tr>
          <tr>
            <td> <p>String</p></td>
            <td> <p>Performs operations on character values (char<span class="emphasis">,</span> varchar,
                nchar, nvarchar, and CLOB) and returns a string or numeric value.</p></td>
          </tr>
        </table></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <p>Note that CASE and CAST are both functions. However, they are detailed
          in
          <link linkend="ch03-1-fm2xml">
          Chapter 3
          </link>
          because of their complexity and frequent usage in SQL-data statements.</p></td>
    </tr>
  </table>
</DIV>
<DIV id="BUILT IN">
  <table border="0" cellspacing="0" cellpadding="0" width="100%">
    <tr>
      <td valign="top" class="name">Built-in Scalar Functions</td>
      <td valign="top" nowrap class="compatibility"> </td>
    </tr>
    <tr>
      <td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"> <p>SQL99 built-in scalar
          functions identify the current user session, and also characteristics
          of the current user session, such as the current session privileges.
          Built-in scalar functions are almost always nondeterministic. The first
          three functions listed in
          <link linkend="ch04-84804">
          Table 4.3
          </link>
          are built-in functions that fall into the date-and-time category of
          functions. Although the four vendors provide many additional functions
          beyond these SQL built-ins, the SQL standard declares only those listed
          in
          <link linkend="ch04-84804">
          Table 4.3
          </link>
          .</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"><span class="title">SQL99
          Built-in Scalar Functions </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <table  border="1">
          <tr>
            <th> <p>Function</p></th>
            <th> <p>Usage</p></th>
          </tr>
          <tr>
            <td> CURRENT_DATE</td>
            <td> <p>Identifies the current date.</p></td>
          </tr>
          <tr>
            <td> CURRENT_TIME </td>
            <td> <p>Identifies the current time.</p></td>
          </tr>
          <tr>
            <td> CURRENT_TIMESTAMP </td>
            <td> <p>Identifies the current date and time.</p></td>
          </tr>
          <tr>
            <td> CURRENT_USER </td>
            <td> <p>Identifies the currently active user within the database
                server.</p></td>
          </tr>
          <tr>
            <td> SESSION_USER </td>
            <td> <p>Identifies the currently active Authorization ID, if it differs
                from the user.</p></td>
          </tr>
          <tr>
            <td> SYSTEM_USER </td>
            <td> <p>Identifies the currently active user within the host operating
                systm.</p></td>
          </tr>
        </table></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <p>Microsoft SQL Server supports all the built-in scalar functions.
          Oracle does not support the built-in scalar functions shown above;
          however, it supports USER as a synonym of CURRENT_USER and SYSDATE
          as a synonym of CURRENT_TIMESTAMP. MySQL supports all the SQL99 built-in
          scalar functions, plus both of Oracle's variants. PostgreSQL supports
          USER, as defined in SQL99, as a synonym for CURRENT_USER. In addition,
          MySQL supports NOW( ) and UNIX_TIMESTAMP (MySQL) as synonyms of the
          function CURRENT_TIMESTAMP. PostgreSQL supports all the SQL99 built-in
          scalar functions except SESSION_USER.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Examples</span> </td>
    </tr>
    <tr>
      <td> <p>The following queries retrieve the values from built-in functions.
          Notice that the various vendors return dates in their native formats:</p>
        <p>/* On MySQL */</p>
        <span class="programlisting">
        <pre>SELECT CURRENT_TIMESTAMP;
-&gt; '2001-12-15 23:50:26'</pre>
        </span>
        <P>/* On Microsoft SQL Server */</p>
        <span class="programlisting">
        <pre>SELECT CURRENT_TIMESTAMP
GO
-&gt; 'Dec 15,2001 23:50:26'</pre>
        </span>
        <P>/* On Oracle */</p>
        <span class="programlisting">
        <pre>SELECT USER FROM dual;
-&gt; dylan</pre>
        </span> </td>
    </tr>
  </table>
</DIV>
<DIV id="NUMERIC">
  <table border="0" cellspacing="0" cellpadding="0" width="100%">
    <tr>
      <td valign="top" class="name">Numeric Scalar Functions</td>
      <td valign="top" nowrap class="compatibility"> </td>
    </tr>
    <tr>
      <td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"> <p>The list of official
          SQL99 numeric functions is rather small. The various vendors provide
          quite a large supplement of mathematical and statistical functions.
          MySQL supports many of these commands in its SQL99 incarnations. The
          other database products offer the same capabilities of numeric scalar
          functions through their own internally defined functions, but they
          do not share the same name as those declared by the SQL standard. The
          supported numeric functions and syntax are listed in
          <link linkend="ch04-70012">
          Table 4.4
          </link>
          .</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"><span class="title">SQL99
          Numeric Functions </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <table border="1" align="center">
          <tr>
            <th> <p>Function</p></th>
            <th> <p>Usage</p></th>
          </tr>
          <tr>
            <td> BIT_LENGTH(expression) </td>
            <td> <p>Returns an integer value representing the number of bits
                in an expression.</p></td>
          </tr>
          <tr>
            <td> CHAR_LENGTH(expression) </td>
            <td> <p>Returns an integer value representing the number of characters
                in an expression.</p></td>
          </tr>
          <tr>
            <td> EXTRACT(datetime_expression datepart FROM expression) </td>
            <td> <p>Allows the datepart to be extracted (YEAR, MONTH, DAY, HOUR,
                MINUTE, SECOND, TIMEZONE_HOUR, or TIMEZONE_MINUTE ) from an expression.</p></td>
          </tr>
          <tr>
            <td> OCTET_LENGTH(expression) </td>
            <td> <p>Returns an integer value representing the number of octets
                in an expression. This value is the same as BIT_LENGTH/8.</p></td>
          </tr>
          <tr>
            <td> POSITION(starting_string IN search_string) </td>
            <td> <p>Returns an integer value representing the starting position
                of a string within the search string.</p></td>
          </tr>
        </table></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"><span class="title"> BIT_LENGTH,
          CHAR_LENGTH, and OCTET_LENGTH</span></td>
    </tr>
    <tr>
      <td> <p>The closest any of the vendors get to the BIT_LENGTH function is
          Oracle. Oracle supports the LENGTHB function, which returns an integer
          value representing the number of bytes in an expression.</p>
        <p>MySQL and PostgreSQL support CHAR_LENGTH and the SQL99 synonym CHARACTER_LENGTH(
          ). PostgreSQL also supports EXTRACT( ), OCTET_LENGTH( ), and POSITION(
          ) as per the SQL99 standard. The other two vendors each have a similar
          function that provides identical functionality. SQL Server provides
          the LEN function and Oracle provides the LENGTH function.</p>
        <p>MySQL and PostgreSQL also fully support the OCTET_LENGTH function.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Example</span> </td>
    </tr>
    <tr>
      <td> <p>The following example determines the length of a string and a value
          retrieved from a column:</p>
        <P>/* On MySQL and PostgreSQL */</p>
        <span class="programlisting">
        <pre>SELECT CHAR_LENGTH('hello');
SELECT OCTET_LENGTH(book_title) FROM titles;</pre>
        </span>
        <P>/* On Microsoft SQL Server */</p>
        <span class="programlisting">
        <pre>SELECT DATALENGTH(title)
FROM titles
WHERE type = 'popular_comp'
GO</pre>
        </span>
        <P>/* On Oracle */</p>
        <span class="programlisting">
        <pre>SELECT LENGTH('HORATIO') "Length of characters"
FROM dual;</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">EXTRACT </span></td>
    </tr>
    <tr>
      <td> <p>The EXTRACT function is not supported by the database vendors,
          except for PostgreSQL and MySQL.</p>
        <p>Each vendor supports a separate command to accomplish the same functionality.
          Oracle uses the TO_CHAR function to extract a portion of a date into
          a character string. SQL Server uses the CONVERT function to extract
          a portion of a date.</p>
        <p>MySQL implementation is extended somewhat beyond the SQL99 standard.
          The SQL99 standard does not have a provision for returning multiple
          fields in the same call to EXTRACT( ) (e.g., "DAY_HOUR"). The MySQL
          extensions try to accomplish what the combination DATE_TRUNC( ) and
          DATE_PART( ) do in PostgreSQL. MySQL supports the dateparts listed
          in
          <link linkend="ch04-89585">
          Table 4.5
          </link>
          .</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">MySQL
          Dateparts </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <table border="1" align="center">
          <tr>
            <th> <p>Type value</p></th>
            <th> <p>Meaning</p></th>
            <th> <p>Expected format</p></th>
          </tr>
          <tr>
            <td> <p>SECOND</p></td>
            <td> <p>Seconds</p></td>
            <td> <p>SECONDS</p></td>
          </tr>
          <tr>
            <td> <p>MINUTE</p></td>
            <td> <p>Minutes</p></td>
            <td> <p>MINUTES</p></td>
          </tr>
          <tr>
            <td> <p>HOUR</p></td>
            <td> <p>Hours</p></td>
            <td> <p>HOURS</p></td>
          </tr>
          <tr>
            <td> <p>DAY</p></td>
            <td> <p>Days</p></td>
            <td> <p>DAYS</p></td>
          </tr>
          <tr>
            <td> <p>MONTH</p></td>
            <td> <p>Months</p></td>
            <td> <p>MONTHS</p></td>
          </tr>
          <tr>
            <td> <p>YEAR</p></td>
            <td> <p>Years</p></td>
            <td> <p>YEARS</p></td>
          </tr>
          <tr>
            <td> <p>MINUTE_SECOND</p></td>
            <td> <p>Minutes and seconds</p></td>
            <td> <p>"MINUTES:SECONDS"</p></td>
          </tr>
          <tr>
            <td> <p>HOUR_MINUTE</p></td>
            <td> <p>Hours and minutes</p></td>
            <td> <p>"HOURS:MINUTES"</p></td>
          </tr>
          <tr>
            <td> <p>DAY_HOUR</p></td>
            <td> <p>Days and hours</p></td>
            <td> <p>"DAYS HOURS"</p></td>
          </tr>
          <tr>
            <td> <p>YEAR_MONTH</p></td>
            <td> <p>Years and months</p></td>
            <td> <p>"YEARS-MONTHS"</p></td>
          </tr>
          <tr>
            <td> <p>HOUR_SECOND</p></td>
            <td> <p>Hours, minutes, seconds</p></td>
            <td> <p>"HOURS:MINUTES:SECONDS"</p></td>
          </tr>
          <tr>
            <td> <p>DAY_MINUTE</p></td>
            <td> <p>Days, hours, minutes</p></td>
            <td> <p>"DAYS HOURS:MINUTES"</p></td>
          </tr>
          <tr>
            <td> <p>DAY_SECOND</p></td>
            <td> <p>Days, hours, minutes, seconds</p></td>
            <td> <p>"DAYSHOURS:MINUTES:SECONDS"</p></td>
          </tr>
        </table></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Example</span> </td>
    </tr>
    <tr>
      <td> <p>This example extracts dateparts from several datetime values:</p>
        <P>/* On MySQL */</p>
        <span class="programlisting">
        <pre>SELECT EXTRACT(YEAR FROM "2013-07-02");
-&gt; 1999
SELECT EXTRACT(YEAR_MONTH FROM "2013-07-02 01:02:03");
-&gt; 199907
SELECT EXTRACT(DAY_MINUTE FROM "2013-07-02 01:02:03");
-&gt; 20102</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">POSITION</span> </td>
    </tr>
    <tr>
      <td> <p>The POSITION function returns an integer that indicates the starting
          position of a string within the search string. MySQL and PostgreSQL
          support the POSITION function with no variation from the SQL99 syntax.
          PostgreSQL has a synonymous function, TEXTPOS, while MySQL has the
          synonymous function, LOCATE.</p>
        <p>Oracle's equivalent function is called INSTR. Microsoft SQL Server
          has both CHARINDEX and PATINDEX. The CHARINDEX and PATINDEX are very
          similar, except that PATINDEX allows the use of wildcard characters
          in the search criteria. For example:</p>
        <span class="programlisting">
        <pre>/* On MySQL */
SELECT LOCATE('bar', 'foobar');
-&gt; 4
<P>/* On MySQL and PostgreSQL */</p>
SELECT POSITION('fu' IN 'snafhu');
-&gt; 0
<P>/* On Microsoft SQL Server */</p>
SELECT CHARINDEX( 'de', 'abcdefg' )
GO
-&gt; 4
SELECT PATINDEX( '%fg', 'abcdefg' )
 GO
-&gt; 6</pre>
        </span> </td>
    </tr>
  </table>
</DIV>
<DIV id="STRING">
  <table border="0" cellspacing="0" cellpadding="0" width="100%">
    <tr>
      <td valign="top" class="name">String Functions</td>
      <td valign="top" nowrap class="compatibility"> </td>
    </tr>
    <tr>
      <td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"> <p>Basic string functions
          offer a number of capabilities and return a string value as a result
          set. Some string functions are dyadic, indicating that they operate
          on two strings at once. SQL99 supports the string functions listed
          in
          <link>
          Table 4.6
          </link>
          .</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="description"><span class="title">SQL
          String Functions</span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td> <table border="1" align="center">
          <tr>
            <th> <p>Function</p></th>
            <th> <p>Usage</p></th>
          </tr>
          <tr>
            <td> CONCATENATE(expression || expression) </td>
            <td> <p>Appends two or more literal expressions, column values, or
                variables together into one string.</p></td>
          </tr>
          <tr>
            <td> CONVERT </td>
            <td> <p>Converts a string to a different representation within the
                same character set.</p></td>
          </tr>
          <tr>
            <td> LOWER </td>
            <td> <p>Converts a string to all lowercase characters.</p></td>
          </tr>
          <tr>
            <td> SUBSTRING </td>
            <td> <p>Extracts a portion of a string.</p></td>
          </tr>
          <tr>
            <td> TRANSLATE </td>
            <td> <p>Converts a string from one character set to another.</p></td>
          </tr>
          <tr>
            <td> TRIM </td>
            <td> <p>Removes leading characters, trailing characters, or both
                from a character string.</p></td>
          </tr>
          <tr>
            <td> UPPER </td>
            <td> <p>Converts a string to all uppercase characters.</p></td>
          </tr>
        </table></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">CONCATENATE</span> </td>
    </tr>
    <tr>
      <td> <p>SQL99 defines a concatenation operator ( || ), which joins two
          distinct strings into one string value. The CONCATENATE function appends
          two or more strings together, producing a single output string. PostgreSQL
          and Oracle support the double-concatenation operator. Microsoft SQL
          Server uses the plus sign (+) concatenation operator.</p>
        <p>MySQL supports a similar function, CONCAT( ). Refer to
          <link linkend="ch03-16587">
          Concatenation Operators
          </link>
          in
          <link linkend="ch03-1-fm2xml">
          Chapter 3
          </link>
          , for more information on concatenation within Oracle, PostgreSQL,
          and Microsoft SQL Server.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">SQL99
          Syntax</span>
        <P>CONCATENATE('string1' || 'string2')</P></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">MySQL
          Syntax</span> <span class="programlisting">
        <pre>CONCAT(str1, str2, [,...n])</pre>
        </span>
        <p>If any of the concatenation values are null, the entire returned string
          is null. Also, if a numeric value is concatenated, it is implicitly
          converted to a character string:</p>
        <span class="programlisting">
        <pre>SELECT CONCAT('My ', 'bologna ', 'has ', 'a ', 'first ', 'name...');
-&gt; 'My bologna has a first name...'
SELECT CONCAT('My ', NULL, 'has ', 'first ', 'name...');
-&gt; NULL</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">CONVERT
          and TRANSLATE</span> </td>
    </tr>
    <tr>
      <td> <p>The CONVERT function alters the representation of a character string
          within its character set and collation. For example, CONVERT might
          be used to alter the number of bits per character.</p>
        <p>TRANSLATE alters the character set of a string value from one base-character
          set to another. Thus, TRANSLATE might be used to translate a value
          from the English character set to a Kanji (Japanese) or Russian character
          set. The translation must already exist, either by default or having
          been created using the CREATE TRANSLATION command.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">SQL99
          Syntax</span>
        <P>CONVERT (char_value target_char_set USING form_of_use source_char_name)
          TRANSLATE(char_value target_char_set USING translation_name) </p>
        <p>Among the database vendors, only Oracle supports CONVERT and TRANSLATE
          with the same meaning as SQL99. Oracle's implementation of TRANSLATE
          is very similar to SQL99, but not identical. In its implementation,
          Oracle accepts only two arguments and allows translating only between
          the database character set or the national language support character
          set.</p>
        <p>MySQL's implementation of the CONVERT function only translates numbers
          from one base to another. In contrast, Microsoft SQL Server's implementation
          of CONVERT is a very rich utility that alters the base datatype of
          an expression, but is otherwise dissimilar to the SQL99 CONVERT function.
          PostgreSQL does not support CONVERT, and its implementation of TRANSLATE
          serves to morph any occurrence of a character string to any other character
          string.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">MySQL
          Syntax and Variations</span> <span class="programlisting">
        <pre>CONV(int, from_base, to_base)</pre>
        </span>
        <p>MySQL does not support TRANSLATE. This implementation of CONVERT returns
          a string value representing the number as it is converted from the
          from_base value to the to_base value. If any of the numbers are NULL,
          then the function returns NULL. Following are some examples:</p>
        <span class="programlisting">
        <pre>SELECT CONV("a",16,2);
-&gt; '1010'
SELECT CONV("6E",18,8);
-&gt; '172'
SELECT CONV(-17,10,-18);
-&gt; '-H'</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Microsoft
          SQL Server Syntax and Variations</span> <span class="programlisting">
        <pre>CONVERT (data_type[(length) | (precision,scale)], expression[,style])</pre>
        </span>
        <p>Microsoft SQL Server does not support TRANSLATE. Microsoft's implementation
          of the CONVERT function does not follow the SQL99 specification. Instead,
          it is functionally equivalent to the CAST function. The style clause
          is used to define the format of a date conversion. Refer to the vendor
          documentation for more information. Following is an example:</p>
        <span class="programlisting">
        <pre>SELECT title, CONVERT(char(7), ytd_sales) FROM titles ORDER BY title GO</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Oracle
          Syntax and Variations</span> <span class="programlisting">
        <pre>CONVERT('char_value', target_char_set, source_char_set) TRANSLATE('char_value', 'from_text', 'to_text')</pre>
        </span>
        <p>Under Oracle's implementation, the CONVERT function returns the <span class="emphasis">char_value</span> in
          the target character set. The <span class="emphasis">char_value</span> is
          the string being converted, while the <span class="emphasis">target_char_set</span> is
          the name of the character set where the <span class="emphasis">char_value</span> is
          converted. <span class="emphasis">Source_char_set</span> is the name
          of the character set where the <span class="emphasis">char_value</span> was
          originally stored.</p>
        <p>Both the target and source character set can be either literals strings,
          variables, or columns containing the name of the character set. Note
          that inadequate replacement characters might be substituted when converting
          from or to a character set that does not support a representation of
          all the characters used in the conversion.</p>
        <p>Oracle supports several common character sets including US7ASCII,
          WE8DECDEC, WE8HP, F7DEC, WE8EBCDIC500, WE8PC850, and WE8ISO8859P1.
          For example:</p>
        <span class="programlisting">
        <pre>SELECT CONVERT('Gro&#223;', 'US7ASCII', 'WE8HP')
FROM DUAL;
-&gt;Gross</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">PostgreSQL
          Syntax and Variations</span> <span class="programlisting">
        <pre>TRANSLATE (character_string, from_text, to_text)</pre>
        </span>
        <p>PostgreSQL does not support CONVERT. PostgreSQL's implementation of
          the TRANSLATE function offers a large superset of functions compared
          to that found in the SQL99 specification. Instead, it converts any
          occurrence of one text string to another within another specified string.
          Here is an example:</p>
        <span class="programlisting">
        <pre>SELECT TRANSLATE('12345abcde', '5a', 'XX');
-&gt; 1234XXbcde

SELECT TRANSLATE(title, 'Computer', 'PC')
FROM  titles
WHERE type = 'Personal_computer'</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">LOWER
          and UPPER</span></td>
    </tr>
    <tr>
      <td> <p>The functions LOWER and UPPER allow the case of a string to be
          altered quickly and easily, so that all the characters are lower- or
          uppercase, respectively. These functions are supported in all the database
          implementations covered in this book.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Example</span> <span class="programlisting">
        <pre>SELECT LOWER('You Talkin To ME?'), UPPER('you talking to me?!');
-&gt; you talking to me?, YOU TALKIN TO ME?!</pre>
        </span>
        <p>The various database vendors also support a variety of other text
          formatting functions that are specific to their implementation.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">SUBSTRING</span></td>
    </tr>
    <tr>
      <td> <p>The SUBSTRING function allows one character string to be extracted
          from another.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">SQL99
          Syntax</span> <span class="programlisting">
        <pre>SUBSTRING(extraction_string FROM starting_position [FOR length]
[COLLATE collation_name])</pre>
        </span>
        <p>If any of the inputs are NULL, the SUBSTRING function returns a NULL.
          The <span class="emphasis">extraction_string</span> is where the character
          value is extracted from. It may be a literal string, a column in a
          table with a character datatype, or a variable with a character datatype.
          The <span class="emphasis">starting_position</span> is an integer value
          telling the function at which position to perform the extract. The
          optional <span class="emphasis">length </span>is an integer value that
          tells the function how many characters to extract, starting at the <span class="emphasis">starting_position</span>.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">MySQL
          Syntax and Variations</span> <span class="programlisting">
        <pre>SUBSTRING(extraction_string FROM starting_position)</pre>
        </span>
        <p>MySQL's implementation assumes that the characters are to be extracted
          from the starting position continuing to the end of the character string.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Microsoft
          SQL Server Syntax and Variations</span> <span class="programlisting">
        <pre>SUBSTRING(extraction_string [FROM starting_position] [FOR length])</pre>
        </span>
        <p>Microsoft SQL Server largely supports the SQL99 standard, except that
          it does not allow the COLLATE clause. Microsoft allows this command
          to be applied to text, image, and binary datatypes; however, the starting_position
          and length represent the number of bytes rather than the number of
          characters to count.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Oracle
          Syntax and Variations</span> <span class="programlisting">
        <pre>SUBSTR(extraction_string, starting_position [, length])</pre>
        </span>
        <p>Oracle's implementation, SUBSTR, largely functions the same way as
          SQL99. It does not support the COLLATE clause. When a <span class="emphasis">starting_value</span> is
          a negative number, Oracle counts from the end of the <span class="emphasis">extraction_string</span>.
          If length is omitted, the remainder of the string (starting at <span class="emphasis">starting_position</span>)
          is returned.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">PostgreSQL
          Syntax and Variations</span> <span class="programlisting">
        <pre>SUBSTRING(extraction_string [FROM starting_position] [FOR length])</pre>
        </span>
        <p>PostgreSQL largely supports the SQL99 standard, except that it does
          not accept the COLLATE clause.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Examples</span></td>
    </tr>
    <tr>
      <td> <p>These examples generally work on any one of the four database vendors
          profiled in this book. Only the second Oracle example, with a negative
          starting position, fails on the others (assuming, of course, that Oracle's
          SUBSTR is translated into SUBSTRING ):</p>
        <span class="programlisting">
        <pre><p>/* On Oracle, counting from the left */</p>
SELECT SUBSTR('ABCDEFG',3,4) FROM DUAL;
-&gt; CDEF
<P>/* On Oracle, counting from the right */
SELECT SUBSTR('ABCDEFG',-5,4) FROM DUAL;
-&gt; CDEF
<P>/* On MySQL */</p>
SELECT SUBSTRING('Be vewy, vewy quiet',5);
-&gt; 'wy, vewy quiet''
<P>/* On PostgreSQL or SQL Server */</p>
SELECT au_lname, SUBSTRING(au_fname, 1, 1)
FROM authors
WHERE au_lname = 'Carson'
-&gt; Carson     C
</pre>
        </span> </td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">TRIM</span></td>
    </tr>
    <tr>
      <td> <p>The TRIM function removes leading spaces, trailing characters,
          or both from a specified character string. This function also removes
          other types of characters from a specified character string. The default
          function is to trim the specified character from both sides of the
          character string. If no removal string is specified, TRIM removes spaces
          by default.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">SQL99
          Syntax</span> <span class="programlisting">
        <pre>TRIM( [ [{LEADING | TRAILING | BOTH}] [removal_string] FROM ]
  target_string
  [COLLATE collation_name])</pre>
        </span>
        <p>The removal_string is the character string to be stripped out. The
          target _string is the character string from which characters are to
          be taken. If a removal_string is not specified, then TRIM strips out
          spaces. The COLLATE clause forces the result set of the function into
          another preexisting collation set.</p>
        <p>MySQL, PostgreSQL, and Oracle support the SQL99 syntax of TRIM.</p>
        <p>Microsoft SQL Server (and the other vendors for that matter) provide
          the functions LTRIM and RTRIM to trim off leading spaces or trailing
          spaces, respectively. LTRIM and RTRIM cannot be used to trim other
          types of characters.</p></td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="CLEARSEPARATION">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" colspan="2" class="example"><span class="title">Examples</span> <span class="programlisting">
        <pre>SELECT TRIM('   wamalamadingdong  ');
-&gt; 'wamalamadingdong'
SELECT TRIM(LEADING '19' FROM '1976 AMC GREMLIN');
-&gt; '76 AMC GREMLIN'
SELECT TRIM(BOTH 'x' FROM 'xxxWHISKEYxxx');
-&gt; 'WHISKEY'
SELECT TRIM(TRAILING 'snack' FROM 'scooby snack');
-&gt; 'scooby '</pre>
        </span> </td>
    </tr>
  </table>
</DIV>
</body>
</html>
